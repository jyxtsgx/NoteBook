[TOC]

## 外观模式

### 介绍
外观模式是一种简单的模式，它为对象提供了一个可供选择的接口。这是一个非常好的设计实践，可保持方法的简洁性并且不会使它们处理过多的工作。

### 基本实现
外观模式不仅简化类中的接口，而且对接口与调用者也进行了解耦。外观模式经常被认为开发者必备，它可以将一些复杂操作封装起来，并创建一个简单的接口用于调用。

外观模式经常被用于Javascript类库里，通过它封装一些接口用于兼容多浏览器，也可以让我们间接调用子系统，从而避免因直接访问子系统而产生不必要的错误。

有时候，两个或更多的方法可能普遍的被一起调用。在这样的情况下，创建另一个方法以包装重复的方法调用是非常有意义的。

例如，当处理浏览器事件时，你有一下方法：
```
e.stopPropagation();  // 中止事件以避免其冒泡上升到父节点
e.preventDefault();  // 阻止浏览器执行默认动作
```
以上是两个单独的方法且各自具有不同的目标，它们之间应保持相互独立，但在同一时间，它们经常被一起调用。为此，并不需要在程序中到处复制这两个方法调用，可以创建一个外观方法来封装：
```
var myevent = {
  // ...
  stop: function (e) {
    e.stopPropagation();
    e.preventDefault();
  }
  // ...
}
```
外观模式也非常适合于浏览器脚本处理，据此可将浏览器之间的差异隐藏在外观之后。
```
var myevent = {
  // ...
  stop: function (e) {
    // others
    if (typeof e.preventDefault === 'function') {
      e.preventDefault();
    }
    if (typeof e.stopPropagation === 'function') {
      e.stopPropagation();
    }
    // IE
    if (typeof e.returnValue === 'boolean') {
      e.returnValue = false;
    }
    if (typeof e.cancelBubble === 'boolean') {
      e.cancelBubble = false;
    }
  }
  // ...
}
```

### 总结
那么何时使用外观模式呢？一般来说分三个阶段：

首先，在设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观Facade。

其次，在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少他们之间的依赖。

第三，在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观Facade也是非常合适的，为系系统开发一个外观Facade类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和Facade对象交互，Facade与遗留代码交互所有的复杂工作。